[["version", 4], ["markdown", "<!-- contributed by Nickolay Ponomarev [asqueella@gmail.com] -->\n<!-- contributed by Myk Melez [myk@mozilla.org] -->\n<!-- contributed by Irakli Gozalishvil [gozala@mozilla.com] -->\n\nOverview\n--------\nThe page-mod module enables add-on developers to execute scripts in the context\nof specific web pages. Most obviously you could use page-mod to dynamically\nmodify the content of certain pages.\n\nThe module exports a constructor function `PageMod` which creates a new page\nmodification (or \"mod\" for short).\n\nA page mod does not modify its pages until those pages are loaded or reloaded.\nIn other words, if your add-on is loaded while the user's browser is open, the\nuser will have to reload any open pages that match the mod for the mod to affect\nthem.\n\nTo stop a page mod from making any more modifications, call its `destroy`\nmethod.\n\nLike all modules that interact with web content, page-mod uses content\nscripts that execute in the content process and defines a messaging API to\ncommunicate between the content scripts and the main add-on script. For more\ndetails on content scripting see the tutorial on [interacting with web\ncontent](dev-guide/addon-development/web-content.html).\n\nTo create a PageMod the add-on developer supplies:\n\n* a set of rules to select the desired subset of web pages based on their URL.\nEach rule is specified using the\n[match-pattern](packages/api-utils/docs/match-pattern.html) syntax.\n\n* a set of content scripts to execute in the context of the desired pages.\n\n* a value for the onAttach option: this value is a function which will be\ncalled when a page is loaded that matches the ruleset. This is used to set up a\ncommunication channel between the add-on code and the content script.\n\nAll these parameters are optional except for the ruleset, which must include\nat least one rule.\n\nThe following add-on displays an alert whenever a page matching the ruleset is\nloaded:\n\n    var pageMod = require(\"page-mod\");\n    pageMod.PageMod({\n      include: \"*.org\",\n      contentScript: 'window.alert(\"Page matches ruleset\");'\n    });\n\nIf you specify a value of \"ready\" or \"end\" for `contentScriptWhen`,\nthen the content script can interact with the DOM itself:\n\n    var pageMod = require(\"page-mod\");\n    pageMod.PageMod({\n      include: \"*.org\",\n      contentScriptWhen: 'end',\n      contentScript: 'document.body.innerHTML = ' +\n                     ' \"<h1>Page matches ruleset</h1>\";'\n    });\n\n### Using `contentScriptFile` ###\n\nMost of the examples in this page define content scripts as strings,\nand use the `contentScript` option to assign them to page mods.\n\nIn your code you will more often create content scripts in separate files\nunder your add-on's `data` directory. Then you can use the\n[`self`](packages/addon-kit/docs/self.html) module to retrieve a URL pointing\nto the file, and assign this to the page-mod's `contentScriptFile`\nproperty.\n\nFor example, if you save the content script\nfile in your `data` directory as \"myScript.js\", you would assign it using\ncode like:\n\n    var data = require(\"self\").data;\n    \n    var pageMod = require(\"page-mod\");\n    pageMod.PageMod({\n      include: \"*.org\",\n      contentScriptWhen: 'end',\n      contentScriptFile: data.url(\"myScript.js\")\n    });\n\n## Communicating With Content Scripts ##\n\nWhen a matching page is loaded the `PageMod` will call the function that the\nadd-on code supplied to `onAttach`. The `PageMod` supplies one argument to\nthis function: a `worker` object.\n\nThe worker can be thought of as the add-on's end of\na communication channel between the add-on code and the content scripts that\nhave been attached to this page.\n\nThus the add-on can pass messages to the content scripts by calling the\nworker's `postMessage` function and can receive messages from the content\nscripts by registering a function as a listener to the worker's `on` function.\n\nNote that if multiple matching pages are loaded simultaneously then each page\nis loaded into its own execution context with its own copy of the content\nscripts. In this case `onAttach` is called once for each loaded page, and the\nadd-on code will have a separate worker for each page:\n\n![Multiple workers](static-files/media/multiple-workers.jpg)\n\nThis is demonstrated in the following example:\n\n    var pageMod = require(\"page-mod\");\n    var tabs = require(\"tabs\");\n\n    var workers = [];\n\n    pageMod.PageMod({\n      include: [\"http://www.mozilla*\"],\n      contentScriptWhen: 'end',\n      contentScript: \"onMessage = function onMessage(message) {\" +\n                     \"  window.alert(message);};\",\n      onAttach: function onAttach(worker) {\n        if (workers.push(worker) == 3) {\n          workers[0].postMessage(\"The first worker!\");\n          workers[1].postMessage(\"The second worker!\");\n          workers[2].postMessage(\"The third worker!\");\n        }\n      }\n    });\n\n    tabs.open(\"http://www.mozilla.com\");\n    tabs.open(\"http://www.mozilla.org\");\n    tabs.open(\"http://www.mozilla-europe.org\");\n\nHere we specify a ruleset to match any URLs starting with\n\"http://www.mozilla\". When a page matches we add the supplied worker to\nan array, and when we have three workers in the array we send a message to\neach worker in turn, telling it the order in which it was attached. The\nworker just displays the message in an alert box.\n\nThis shows that separate pages execute in separate contexts and that each\ncontext has its own communication channel with the add-on script.\n\nNote though that while there is a separate worker for each execution context,\nthe worker is shared across all the content scripts associated with a single\nexecution context. In the following example we pass two content scripts into\nthe `PageMod`: these content scripts will share a worker instance.\n\nIn the example each content script identifies itself to the add-on script\nby sending it a message using the global `postMessage` function. In the\n`onAttach` function the add-on code logs the fact that a new page is\nattached and registers a listener function that simply logs the message:\n\n\n    var pageMod = require(\"page-mod\");\n    var data = require(\"self\").data;\n    var tabs = require(\"tabs\");\n\n    pageMod.PageMod({\n      include: [\"http://www.mozilla*\"],\n      contentScriptWhen: 'end',\n      contentScript: [\"postMessage('Content script 1 is attached to '+ \" +\n                      \"document.URL);\",\n                      \"postMessage('Content script 2 is attached to '+ \" +\n                      \"document.URL);\"],\n      onAttach: function onAttach(worker) {\n        console.log(\"Attaching content scripts\")\n        worker.on('message', function(data) {\n          console.log(data);\n        });\n      }\n    });\n\n    tabs.open(\"http://www.mozilla.com\");\n\nThe console output of this add-on is:\n\n<pre>\n  info: Attaching content scripts\n  info: Content script 1 is attached to http://www.mozilla.com/en-US/\n  info: Content script 2 is attached to http://www.mozilla.com/en-US/\n</pre>\n\n### Mapping workers to tabs ###\n\nThe [`worker`](packages/api-utils/docs/content/worker.html) has a `tab`\nproperty which returns the tab associated with this worker. You can use this\nto access the [`tabs API`](packages/addon-kit/docs/tabs.html) for the tab\nassociated with a specific page:\n\n    var pageMod = require(\"page-mod\");\n    var tabs = require(\"tabs\");\n\n    pageMod.PageMod({\n      include: [\"*\"],\n      onAttach: function onAttach(worker) {\n        console.log(worker.tab.title);\n      }\n    });\n\n### Attaching content scripts to tabs ###\n\nWe've seen that the page mod API attaches content scripts to pages based on\ntheir URL. Sometimes, though, we don't care about the URL: we just want\nto execute a script on demand in the context of a particular tab.\n\nFor example, we might want to run a script in the context of the currently\nactive tab when the user clicks a widget: to block certain content, to\nchange the font style, or to display the page's DOM structure.\n\nUsing the `attach` method of the [`tab`](packages/addon-kit/docs/tabs.html)\nobject, you can attach a set of content scripts to a particular tab. The\nscripts are executed immediately.\n\nThe following add-on creates a widget which, when clicked, highlights all the\n`div` elements in the page loaded into the active tab:\n\n    var widgets = require(\"widget\");\n    var tabs = require(\"tabs\");\n\n    var widget = widgets.Widget({\n      id: \"div-show\",\n      label: \"Show divs\",\n      contentURL: \"http://www.mozilla.org/favicon.ico\",\n      onClick: function() {\n        tabs.activeTab.attach({\n          contentScript:\n            'var divs = document.getElementsByTagName(\"div\");' +\n            'for (var i = 0; i < divs.length; ++i) {' +\n              'divs[i].setAttribute(\"style\", \"border: solid red 1px;\");' +\n            '}'\n        });\n      }\n    });\n\n## Destroying Workers ##\n\nWorkers generate a `detach` event when their associated page is closed: that\nis, when the tab is closed or the tab's location changes. If\nyou are maintaining a list of workers belonging to a page mod, you can use\nthis event to remove workers that are no longer valid.\n\nFor example, if you maintain a list of workers attached to a page mod:\n\n    var workers = [];\n\n    var pageMod = require(\"page-mod\").PageMod({\n      include: ['*'],\n      contentScriptWhen: 'ready',\n      contentScriptFile: data.url('pagemod.js'),\n      onAttach: function(worker) {\n        workers.push(worker);\n      }\n    });\n\nYou can remove workers when they are no longer valid by listening to `detach`:\n\n    var workers = [];\n\n    function detachWorker(worker, workerArray) {\n      var index = workerArray.indexOf(worker);\n      if(index != -1) {\n        workerArray.splice(index, 1);\n      }\n    }\n\n    var pageMod = require(\"page-mod\").PageMod({\n      include: ['*'],\n      contentScriptWhen: 'ready',\n      contentScriptFile: data.url('pagemod.js'),\n      onAttach: function(worker) {\n        workers.push(worker);\n        worker.on('detach', function () {\n          detachWorker(this, workers);\n        });\n      }\n    });\n\n"], ["api-json", {"line_number": 277, "name": "PageMod", "constructors": [{"line_number": 282, "name": "PageMod", "params": [{"line_number": 285, "name": "options", "datatype": "object", "required": true, "props": [{"datatype": "string,array", "line_number": 287, "required": true, "name": "include", "description": "A match pattern string or an array of match pattern strings.  These define\nthe pages to which the PageMod applies.  See the\n[match-pattern](packages/api-utils/docs/match-pattern.html) module for\na description of match pattern syntax.\nAt least one match pattern must be supplied.\n"}, {"datatype": "string,array", "line_number": 294, "required": false, "name": "contentScriptFile", "description": "The local file URLs of content scripts to load.  Content scripts specified\nby this option are loaded *before* those specified by the `contentScript`\noption. Optional."}, {"datatype": "string,array", "line_number": 298, "required": false, "name": "contentScript", "description": "The texts of content scripts to load.  Content scripts specified by this\noption are loaded *after* those specified by the `contentScriptFile` option.\nOptional."}, {"line_number": 302, "name": "contentScriptWhen", "default": "\"end\"", "required": false, "datatype": "string", "description": "When to load the content scripts. This may take one of the following\nvalues:\n\n* \"start\": load content scripts immediately after the document\nelement for the page is inserted into the DOM, but before the DOM content\nitself has been loaded\n* \"ready\": load content scripts once DOM content has been loaded,\ncorresponding to the\n[DOMContentLoaded](https://developer.mozilla.org/en/Gecko-Specific_DOM_Events)\nevent\n* \"end\": load content scripts once all the content (DOM, JS, CSS,\nimages) for the page has been loaded, at the time the\n[window.onload event](https://developer.mozilla.org/en/DOM/window.onload)\nfires\n\nThis property is optional and defaults to \"end\".\n"}, {"datatype": "function", "line_number": 320, "required": false, "name": "onAttach", "description": "A function to call when the PageMod attaches content scripts to\na matching page. The function will be called with one argument, a `worker`\nobject which the add-on script can use to communicate with the content scripts\nattached to the page in question.\n"}], "description": "Options for the PageMod, with the following keys:"}], "signature": "PageMod(options)", "type": "constructor", "description": "Creates a PageMod."}], "events": [{"arguments": [{"datatype": "Worker", "line_number": 350, "description": "The listener function is passed a `Worker` object that can be used to communicate\nwith any content scripts attached to this page."}], "line_number": 345, "type": "event", "name": "attach", "description": "This event is emitted this event when the page-mod's content scripts are\nattached to a page whose URL matches the page-mod's `include` filter.\n"}, {"arguments": [{"datatype": "Error", "line_number": 360, "description": "Listeners are passed a single argument, the\n[Error](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error)\nobject."}], "line_number": 355, "type": "event", "name": "error", "description": "This event is emitted when an uncaught runtime error occurs in one of the page\nmod's content scripts.\n"}], "methods": [{"line_number": 338, "signature": "destroy()", "type": "method", "name": "destroy", "description": "Stops the page mod from making any more modifications.  Once destroyed the page\nmod can no longer be used.  Note that modifications already made to open pages\nwill not be undone."}], "type": "class", "properties": [{"datatype": "List", "line_number": 328, "type": "property", "name": "include", "description": "A [list](packages/api-utils/docs/list.html) of match pattern strings.  These\ndefine the pages to which the page mod applies.  See the\n[match-pattern](packages/api-utils/docs/match-pattern.html) module for a\ndescription of match patterns. Rules can be added to the list by calling its\n`add` method and removed by calling its `remove` method.\n"}], "description": "A PageMod object. Once activated a page mod will execute the supplied content\nscripts in the context of any pages matching the pattern specified by the\n'include' property.\n\n\n\n\n"}], ["markdown", "\n"]]